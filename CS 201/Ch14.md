Look at  109 -> Ch13.md for more content

### Section 1: A Graph

#### What Is a Graph?

In graph theory, a **graph** is a collection of **dots (vertices)** and **lines (edges)** connecting them. It may resemble a *connect-the-dots* game — but instead of forming a picture, it reveals how things are connected.

> Think of a graph as a **map** — the dots are **locations**, and the lines are **paths** or **roads** between them.

---

#### Why Study Graphs?

Although the structure may seem abstract, graphs are used in real-world problems like:

* Mapping **city intersections and roads**
* Designing **network topologies**
* Finding **shortest paths** in logistics
* Modeling **social networks**

> Graph theory helps us analyze and optimize **connections** — in transportation, data, and relationships.

---

#### Vertices

Vertices (also called **nodes**) are the **points** in a graph. They represent objects, locations, or entities.

**Types of Vertices**:

1. **Isolated Vertex** — A vertex with **no connections** (edges)

   * Example: A house with **no road** leading to it

2. **Adjacent Vertices** — Vertices that are **directly connected**

   * Example: Two houses with a **road between them**

3. **Degree of a Vertex** — The **number of edges** connected to it

   * Degree = 0 → Isolated
   * Degree = Even → **Even Vertex**
   * Degree = Odd → **Odd Vertex**

> Degree helps identify how **connected** or **central** a vertex is in the graph.

---

#### Edges

Edges are the **lines** that connect the vertices.

**Types of Edges**:

1. **Multiple Edges** — More than one edge between the same two vertices

   * Example: Two **parallel roads** between two cities

2. **Adjacent Edges** — Edges that **share a common vertex**

   * Example: Roads branching out from the **same intersection**

---

#### Paths and Circuits

A **path** is a sequence of edges connecting a set of vertices.

* **Path Length** — Number of edges in the path

  * Example: From A to B using 3 edges → path length = 3

* **Circuit** — A path that **starts and ends at the same vertex**

  * Example: Walking around a block and returning home

---

#### Connected vs Disconnected Graphs

* A **connected graph** has **paths between all vertices**

  * You can get from any point to any other

* A **disconnected graph** has **separate sections** (components)

  * Some vertices are **cut off** from others

**Component**: A **subgraph** that is internally connected but not linked to the rest of the graph.

---

#### Bridges

A **bridge** is an edge that connects **two separate components**.

* Without the bridge, the components would be **isolated**
* Removing a bridge increases the number of components

> Just like a real bridge, it's the **only link** between two otherwise disconnected areas.

---

#### Lesson Summary

* A **graph** is a set of **vertices (points)** connected by **edges (lines)**.
* **Isolated vertex** — No connections
* **Adjacent vertices** — Directly connected
* **Degree** — Number of edges connected to a vertex

  * Even → Even vertex
  * Odd → Odd vertex
* **Multiple edges** — Same vertices connected by more than one line
* **Adjacent edges** — Share a common vertex
* **Path** — Route from one vertex to another
* **Circuit** — Path that starts and ends at the same vertex
* **Connected graph** — All vertices connected by some path
* **Disconnected graph** — Has separate **components**
* **Bridge** — An edge that connects two components. Remove it, and the graph becomes disconnected

> Graphs may look like dots and lines — but they help solve **complex problems in routing, networking, and optimization**.

---
---

### Section 2: Simple vs. Weighted Graphs

#### What Is a Simple Graph?

A **simple graph** is a foundational model used to represent **connections between pairs of objects**. It is defined by two basic components:

* **Vertices (V)** — also called **nodes**, these are the dots or points
* **Edges (E)** — the **lines** connecting the vertices

> Think of a simple graph as a **map** of locations (vertices) and the roads (edges) between them — without any distances or weights.

---

#### What Is a Weighted Graph?

A **weighted graph** builds on a simple graph by **adding values** to each edge. These values — called **weights (w)** — might represent:

* Distance
* Time
* Cost
* Capacity

Each edge in a weighted graph has a **numerical value** associated with it.

> Weighted graphs allow us to model **real-world optimization problems** like shortest paths, cheapest connections, or most efficient networks.

---

#### Directed vs. Undirected Graphs

Graphs can also be classified based on the **direction of edges**:

1. **Directed Graph (Digraph)**

   * Edges have **arrows** indicating direction
   * A connection from A to B **does not** imply B to A
   * Useful for tasks like **web links**, **social following**, **network flows**

2. **Undirected Graph**

   * Edges have **no arrows**
   * A connection from A to B implies a **two-way** relationship
   * Useful for **bi-directional roads**, **friendships**, **physical connections**

> The direction of edges changes **how we interpret** the graph — and which algorithms we use.

---

#### Graph Representation

There are two standard ways to represent graphs in programming:

---

##### 1. **Adjacency Matrix**

A **2D array** where each cell indicates whether an edge exists between two vertices.

* For **unweighted graphs**:

  * `M[i][j] = 1` means there is an edge

* For **weighted graphs**:

  * `M[i][j] = w` where `w` is the weight of the edge

* In **undirected graphs**, the matrix is **symmetric**

* In **directed graphs**, symmetry is **not required**

**Example — Undirected Adjacency Matrix**

```java
int[][] M_undirected = {
    {0, 3, 0, 0, 0},
    {3, 0, 2, 4, 0},
    {0, 2, 0, 5, 5},
    {0, 4, 5, 0, 2},
    {0, 0, 5, 2, 0}
};
```

**Example — Directed Adjacency Matrix**

```java
int[][] M_directed = {
    {0, 3, 0, 0, 0},
    {0, 0, 2, 4, 0},
    {0, 0, 0, 0, 5},
    {0, 0, 5, 0, 0},
    {0, 0, 0, 2, 0}
};
```

---

##### 2. **Adjacency List**

An array (or map) of linked lists — each vertex stores a **list of its neighbors**.

* **More memory efficient** for sparse graphs
* Can also store **weights** along with the connections

**Example — Undirected Adjacency List**

```java
Map<String, List<AbstractMap.SimpleEntry<String, Integer>>> graphUndirected = new HashMap<>();
graphUndirected.put("A", List.of(new AbstractMap.SimpleEntry<>("B", 3)));
...
```

**Example — Directed Adjacency List**

```java
Map<String, List<AbstractMap.SimpleEntry<String, Integer>>> graphDirected = new HashMap<>();
graphDirected.put("A", List.of(new AbstractMap.SimpleEntry<>("B", 3)));
...
```

---

#### Printing a Directed Adjacency List

```java
public static void printGraph(Map<String, List<AbstractMap.SimpleEntry<String, Integer>>> graph) {
    for (Map.Entry<String, List<AbstractMap.SimpleEntry<String, Integer>>> entry : graph.entrySet()) {
        System.out.print(entry.getKey() + " -> ");
        for (AbstractMap.SimpleEntry<String, Integer> edge : entry.getValue()) {
            System.out.print("(" + edge.getKey() + ", " + edge.getValue() + ") ");
        }
        System.out.println();
    }
}
```

---

#### Dijkstra’s Algorithm — Finding the Shortest Path

**Dijkstra's Algorithm** is used with **weighted graphs** to find the **shortest path** from a source node to all other nodes — as long as all weights are **non-negative**.

---

##### Step-by-Step Breakdown:

1. **Initialization**:

   * Set `dist(source) = 0`
   * Set `dist(v) = ∞` for all other vertices
   * Add all nodes to a **priority queue (Q)**

2. **Main Loop**:

   * Extract the node `u` with the **smallest distance**
   * For each neighbor `v` of `u`:

     * If `dist(u) + weight(u, v) < dist(v)`, update:

       * `dist(v) = dist(u) + weight(u, v)`
       * `pred(v) = u`
   * Update the priority queue

3. **Completion**:

   * The `dist[]` array holds the **shortest distance**
   * The `pred[]` array helps reconstruct the **path**

> We use a **priority queue** to reduce time complexity to:
> `O(|E| + |V| log |V|)`

---

#### Lesson Summary

* A **graph** consists of:

  * **Vertices (V)** — the nodes
  * **Edges (E)** — the connections between them
* A **weighted graph** assigns a value (cost, time, distance) to each edge
* Graphs may be:

  * **Directed** — edges have direction (like one-way streets)
  * **Undirected** — edges go both ways
* Graphs can be represented using:

  * **Adjacency Matrix** — best for dense graphs
  * **Adjacency List** — best for sparse graphs
* **Dijkstra’s Algorithm**:

  * Solves the **shortest path** problem
  * Requires **non-negative weights**
  * Uses a **priority queue** for efficient traversal

> Weighted graphs let us **analyze costs and optimize paths**, powering everything from **map navigation** to **network routing**.

---
---

### Section 3: Graphs in Discrete Mathematics

#### What Is a Graph in Discrete Math?

In **discrete mathematics**, a **graph** is a collection of:

* **Vertices** — the **points** (also called nodes)
* **Edges** — the **lines** connecting the points

> A graph is like a **network** that shows how things are linked — cities, people, or even ideas.

---

#### Mary’s Road Trip — A Graph Example

Mary is planning a **road trip**. She draws a map with:

* **Cities** as vertices
* **Roads** as edges
* **Distances** as weights on the edges

This map is a **graph** — and more specifically, it's:

* **Undirected** — roads go both directions
* **Connected** — there’s a path between every city
* **Weighted** — distances are shown as numbers on edges

---

#### Types of Graphs

There are many types of graphs in discrete math. Here's a breakdown of the most common ones:

1. **Null Graph**

   * No edges — just isolated vertices

2. **Connected Graph**

   * Every pair of vertices is connected by some path
   * Example: Mary’s map

3. **Disconnected Graph**

   * Some vertices are not reachable from others

4. **Bipartite Graph**

   * Vertices are divided into **two sets**
   * Edges go **between sets**, not within

5. **Weighted Graph**

   * Each edge has a **numerical value (weight)**
   * Example: Road distances

6. **Directed Graph (Digraph)**

   * Edges have **direction** (arrows)
   * A → B is not the same as B → A

7. **Undirected Graph**

   * No direction — connections go **both ways**
   * Example: Bi-directional roads

8. **Simple Graph**

   * Undirected
   * No **loops** (edges from a vertex to itself)
   * At most **one edge per vertex pair**

9. **Multigraph**

   * Multiple edges between same vertex pair
   * May include **loops**

10. **Planar Graph**

    * Can be drawn **without crossing edges**

11. **Non-Planar Graph**

    * **Cannot** be drawn without edge crossings

> Graph types help define **rules** for how relationships can exist — and determine which algorithms we can use.

---

#### Real-World Applications

Let’s explore two examples of how graphs are applied:

---

##### Example 1 — Mary’s Shortest Route

Mary wants to visit her friend. Each **path** through the graph represents a route. Each **edge weight** is the distance.

**Routes and Distances**:

| Route         | Distance          |
| ------------- | ----------------- |
| M → A → F     | 70 + 50 = 120     |
| M → B → F     | 80 + 60 = 140     |
| M → D → C → F | 30 + 20 + 40 = 90 |

> The shortest route is **M → D → C → F** with a total distance of **90 miles**.

This is an example of the **Shortest Path Problem**, a key question in graph theory and optimization.

---

##### Example 2 — Counseling Matches (Bipartite Graph)

A manager wants to assign **clients to counselors** based on compatibility. The graph:

* Has two sets of vertices: **Clients** and **Counselors**
* Edges connect compatible matches
* No client is connected to another client
* No counselor is connected to another counselor

This is a **bipartite graph** and also a **simple graph**.

If one match doesn’t work — say, **Gabriel and George** — the graph helps quickly find an **alternate connection**, such as **Gabriel and Lucy**.

> Bipartite graphs are ideal for **matching problems** like job assignments, scheduling, and network pairing.

---

#### Lesson Summary

In **discrete mathematics**, a **graph** is a powerful tool for modeling and solving real-world problems. Key takeaways:

* **Graphs** consist of **vertices (nodes)** and **edges (lines)**.
* **Common graph types** include:

  * **Connected / Disconnected**
  * **Directed / Undirected**
  * **Simple / Multigraph**
  * **Weighted / Unweighted**
  * **Planar / Non-Planar**
  * **Bipartite**
* **Graphs are used** for:

  * Finding shortest paths (e.g., Mary’s road trip)
  * Matching problems (e.g., clients and counselors)
  * Modeling networks in computer science, biology, and social media

> Graph theory is at the heart of **discrete math** — and a cornerstone of solving **real-world logic and optimization problems**.

---
---

### Section 4: Data Structure

#### What Is a Data Structure?

A **data structure** is a specialized format for **organizing, storing, and managing data** on a computer. It enables efficient **retrieval**, **modification**, and **processing** of information.

> Imagine storing your **grades** for five subjects. Instead of using five separate variables, a data structure can hold all the data elements together — making calculations (like average, sum, min, max) quick and clean.

---

#### Types of Data Structures

Data structures are classified into two major categories:

---

##### 1. **Linear Data Structures**

* Elements are arranged **sequentially**
* Only **one element** is accessible at a time in a straight path
* Examples:

  * **Array**
  * **Linked List**
  * **Stack**
  * **Queue**

---

##### 2. **Non-Linear Data Structures**

* Elements are arranged in a **non-sequential** format
* One element may link to **multiple others**
* Examples:

  * **Trees**
  * **Graphs**

> Non-linear structures are powerful for modeling **hierarchies** and **networks**.

---

### Section 5: Graph Data Structure

A **graph** is a non-linear data structure that consists of:

* **Vertices (nodes)** — individual elements
* **Edges (links)** — connections between vertices

**Notation**:
A graph `G = (V, E)` where:

* `V` = set of vertices
* `E` = set of edges

**Example**:
`V = {A, B, C, D}`
`E = {(A, B), (B, C), (B, D), (C, D)}`

---

#### Paths in Graphs

A **path** is a sequence of connected edges.

**Examples**:

* Path from A to C: `{(A, B), (B, C)}`
* Path from A to D: `{(A, B), (B, C), (C, D)}`

> Paths allow traversal through the network from one node to another.

---

#### Directed vs. Undirected Graphs

---

**Directed Graph**:

* Edges have a **direction** (one-way)
* Example: `(E → F)` means **you can go from E to F**, but **not vice versa**

---

**Undirected Graph**:

* Edges have **no direction** (two-way)
* You can travel **both directions** between connected nodes

> Directed graphs model **one-way relationships**, like website links; undirected graphs model **mutual connections**, like friendships.

---

#### Cyclic vs. Acyclic Graphs

---

**Cyclic Graph**:

* Contains **at least one cycle**
* A node can be reached again by traversing through its own edges

**Example Path**:
`(B → C), (C → E), (E → D), (D → B)` — cycle back to B

---

**Acyclic Graph**:

* **No cycles**
* No node is revisited on any path

> Acyclic graphs are often used in **hierarchies** like task scheduling or dependencies.

---

#### Dense vs. Sparse Graphs

---

**Maximum Edges**:

* **Directed Graph**: `N × (N - 1)`
* **Undirected Graph**: `N × (N - 1) / 2`

---

**Dense Graph**:

* Has **many edges**, close to the max possible
* Often approximates to `N × N` connections

**Example**: 5 nodes with 12 edges → Dense

---

**Sparse Graph**:

* Has **few edges**, close to the minimum
* Often approximates to `N` connections

**Example**: 5 nodes with only 4 edges → Sparse

> Dense graphs represent highly connected networks; sparse graphs are **efficient** and **lightweight** for limited relationships.

---

#### Lesson Summary

* **Data structures** help organize and manipulate data efficiently.
* Two main categories:

  * **Linear** (Array, Stack, Queue)
  * **Non-linear** (Tree, Graph)
* **Graphs** consist of vertices (nodes) and edges (connections)

  * **Directed Graph** — one-way connections
  * **Undirected Graph** — two-way connections
  * **Cyclic Graph** — contains loops/cycles
  * **Acyclic Graph** — no cycles
  * **Dense Graph** — many edges
  * **Sparse Graph** — few edges

> Graphs are a cornerstone of modern computing — used in networking, search engines, recommendation systems, and more.

---
