### Section 1: Boolean Logic

#### What Is Boolean?

**Boolean logic** refers to a mathematical approach to logic that deals strictly with **two possible truth values**:

* **True (T)** or **False (F)**
* **1** or **0**

The system is named after **George Boole**, who first formulated logic as a symbolic system. Boolean logic obeys the **Law of the Excluded Middle**, meaning **a statement must be either true or false—no in-between**.

---

#### Boolean Variables in Action

A **Boolean variable** holds a value of either `True` or `False`. For example:

* Let `sunny_day = True`
* Let `water_wings = False`

You could use logic like this:

```
IF (sunny_day AND water_wings) THEN go to beach
```

In this case, the overall result is `False`, so you stay home.

---

#### Boolean Logic in Web Search

You've likely used Boolean logic in **search engines** without knowing it:

* Typing `"Thomas Jefferson"` uses the **AND** logic behind the scenes.
* Without quotes, search engines may interpret it as **Thomas OR Jefferson**, giving irrelevant results.

---

#### Common Boolean Operators

| Operator | Meaning                                         | Output Rule                                      |
| -------- | ----------------------------------------------- | ------------------------------------------------ |
| AND      | True if **both** inputs are true                | `True AND True = True`, else False               |
| OR       | True if **at least one** input is true          | `False OR True = True`, etc.                     |
| NOT      | **Reverses** the truth value                    | `NOT True = False`, `NOT False = True`           |
| NAND     | **NOT AND** – True unless both inputs are true  | Reverse of AND                                   |
| NOR      | **NOT OR** – True only if both inputs are false | Reverse of OR                                    |
| XOR      | Exclusive OR – True if only one input is true   | `True XOR True = False`; `True XOR False = True` |

---

#### Truth Tables

##### AND

| P | Q | P AND Q |
| - | - | ------- |
| 0 | 0 | 0       |
| 0 | 1 | 0       |
| 1 | 0 | 0       |
| 1 | 1 | 1       |

##### OR

| P | Q | P OR Q |
| - | - | ------ |
| 0 | 0 | 0      |
| 0 | 1 | 1      |
| 1 | 0 | 1      |
| 1 | 1 | 1      |

##### XOR

| P | Q | P XOR Q |
| - | - | ------- |
| 0 | 0 | 0       |
| 0 | 1 | 1       |
| 1 | 0 | 1       |
| 1 | 1 | 0       |

---

#### Real-World Example: Burglary Alarm

We define:

* `P`: Is it **daytime**? (1 = Yes)
* `Q`: Is a **window open**? (1 = Yes)
* `R`: Are we being **burgled**?

**Formula**:

```
R = NOT(P) AND Q
```

##### Anti-Burglary Truth Table

| P | Q | NOT(P) | R = NOT(P) AND Q |
| - | - | ------ | ---------------- |
| 0 | 0 | 1      | 0                |
| 0 | 1 | 1      | 1                |
| 1 | 0 | 0      | 0                |
| 1 | 1 | 0      | 0                |

* Only when **it's not daytime** and a **window is open**, the alarm is triggered (`R = 1`).

---

#### Lesson Summary

* **Boolean logic** evaluates expressions to either `True`/`False` or `1`/`0`.
* **Operators** like AND, OR, and NOT help us build logical conditions.
* **Truth tables** are useful tools for analyzing Boolean expressions.
* Boolean logic is essential in **computer science**, **search engines**, **electronic circuits**, and **logic-based decision making**.

Use it whenever you need to **evaluate decisions logically and efficiently**.

### Section 2: Boolean Algebra

#### What Is Boolean Algebra?

**Boolean algebra** is a branch of algebra that deals with **truth values**—either **True (1)** or **False (0)**. Created by **George Boole**, this system formalizes **logical reasoning** into algebraic operations and expressions. It plays a crucial role in **digital computing**, **logic circuits**, and **computer programming**.

---

#### Boolean Operations and Truth Tables

Boolean algebra uses special logical operations instead of standard arithmetic:

* **AND** (conjunction)
* **OR** (disjunction)
* **NOT** (negation)

Each operation has a **truth table** showing outcomes for all possible input combinations:

##### AND (`p AND q`)

| p | q | p AND q |
| - | - | ------- |
| 0 | 0 | 0       |
| 0 | 1 | 0       |
| 1 | 0 | 0       |
| 1 | 1 | 1       |

##### OR (`p OR q`)

| p | q | p OR q |
| - | - | ------ |
| 0 | 0 | 0      |
| 0 | 1 | 1      |
| 1 | 0 | 1      |
| 1 | 1 | 1      |

##### NOT (`NOT p`)

| p | NOT p |
| - | ----- |
| 0 | 1     |
| 1 | 0     |

---

#### Combining Boolean Statements

You can build more complex expressions using operations:

* Example:
  If

  * `p = "The sky is blue"` → 1
  * `q = "5 = 6"` → 0
    Then:
  * `p AND q = 1 AND 0 = 0`
  * `p OR q = 1 OR 0 = 1`

**Note**: OR in Boolean algebra is **inclusive**, meaning it evaluates to True if **either or both** operands are True.

---

#### Rules of Boolean Algebra

These laws help simplify complex Boolean expressions:

##### **Double Negation**

* `NOT(NOT p) = p`

##### **Identity Laws**

* `p OR 0 = p`
* `p AND 1 = p`

##### **Null Laws**

* `p OR 1 = 1`
* `p AND 0 = 0`

##### **Idempotent Laws**

* `p OR p = p`
* `p AND p = p`

##### **Inverse Laws**

* `p OR NOT p = 1`
* `p AND NOT p = 0`

##### **Commutative Laws**

* `p OR q = q OR p`
* `p AND q = q AND p`

##### **Associative Laws**

* `(p OR q) OR r = p OR (q OR r)`
* `(p AND q) AND r = p AND (q AND r)`

##### **Distributive Laws**

* `p AND (q OR r) = (p AND q) OR (p AND r)`
* `p OR (q AND r) = (p OR q) AND (p OR r)`

---

#### De Morgan’s Theorems

These rules relate NOT with AND/OR:

* `NOT(p OR q) = (NOT p) AND (NOT q)`
* `NOT(p AND q) = (NOT p) OR (NOT q)`

---

#### Example Simplification

**Expression**:
`NOT (NOT p AND q) AND (p OR q)`

**Step-by-step**:

1. Apply De Morgan’s Law:
   `NOT(NOT p AND q) = (p OR NOT q)`

2. New expression becomes:
   `(p OR NOT q) AND (p OR q)`

3. Apply distributive law:
   `p OR (q AND NOT q)` → since `q AND NOT q = 0` → simplifies to `p`

**Final result**:
`p`

---

#### Lesson Summary

* **Boolean algebra** is logic-based mathematics with values limited to 0 and 1.
* It uses logical operators: **AND**, **OR**, **NOT**.
* **Truth tables** and **Boolean rules** simplify logical expressions.
* It underpins **logic circuits**, **programming conditions**, and **digital computing**.

### Section 3: Boolean Data Type

#### What Is a Boolean Data Type?

A **Boolean data type** is a fundamental concept in programming that can hold only one of two values:

* **True (1)**
* **False (0)**

This binary representation reflects **yes/no**, **on/off**, or **present/absent** logic. The concept was introduced by **George Boole**, a mathematician whose work laid the foundation for modern digital logic and computing.

Boolean data types are crucial in **decision-making processes** within code. They are commonly used in **conditional statements**, **comparisons**, and **logical evaluations**.

---

#### Boolean Expressions

A **Boolean expression** is any expression in programming that **evaluates to either true or false**. These expressions often involve:

* **Relational operators** like `<`, `>`, `==`, `!=`, `<=`, `>=`
* **Logical (Boolean) operators** like `AND`, `OR`, `NOT`

**Example**:

```python
x = 8
y = 7
x < y  # Evaluates to False
```

The result of `x < y` is a Boolean expression that evaluates to `False`, since 8 is not less than 7.

---

#### Boolean Operators

There are three primary **Boolean (logical) operators** used to combine or modify Boolean expressions:

##### NOT

* Negates a Boolean value.
* `NOT(True)` → `False`, `NOT(False)` → `True`

**Example**:

```python
x = 8
y = 7
NOT(x < y)  # x < y is False, so NOT(False) → True
```

##### AND

* Returns `True` only if **both** expressions are `True`.

**Example**:

```python
x = 8
y = 7
z = 6
(x < y) AND (z < y)  # False AND True → False
```

##### OR

* Returns `True` if **at least one** expression is `True`.

**Example**:

```python
x = 8
y = 7
z = 6
(x < y) OR (z < y)  # False OR True → True
```

---

#### Boolean Logic in Practice

Boolean expressions are the **foundation of conditional control structures** such as:

```python
if (x > y):
    print("x is greater")
else:
    print("x is not greater")
```

They are also used in:

* **Search engine queries** (e.g., "cat AND dog", "cat OR dog")
* **Database filters**
* **Loop conditions**
* **Input validation**

---

#### Real-World Analogy in Searches

**Search engine usage** is one area where Boolean logic is applied:

* `"apple AND orange"` → returns pages with **both** words (AND)
* `"apple OR orange"` → returns pages with **either** word (OR)
* `NOT "orange"` → returns pages **excluding** the word "orange" (NOT)

---

#### Lesson Summary

* The **Boolean data type** represents **true or false** values.
* Boolean **expressions** return logical outcomes: `True` or `False`.
* Boolean **operators** include:

  * **NOT** – inverts the value.
  * **AND** – returns true only if both expressions are true.
  * **OR** – returns true if at least one expression is true.
* Boolean logic is essential in **programming**, **search engines**, and **databases** for evaluating conditions and controlling flow.

### Section 4: Karnaugh Map: Definition

#### What Is a Karnaugh Map?

A **Karnaugh Map** (or **K-map**) is a visual method for simplifying Boolean expressions, especially those involving **3 to 6 variables**. It provides a systematic way to minimize logic functions by organizing truth table outputs into a grid, revealing patterns that lead to simplification.

Karnaugh Maps are more **efficient and intuitive** than algebraic methods for mid-sized Boolean functions, bridging the gap between:

* **Boolean Algebra** (best for ≤ 3 variables)
* **Computerized simplification algorithms** (best for > 6 variables)

---

#### Karnaugh Maps vs. Truth Tables

Let’s consider a Boolean function with **three input variables**: `a`, `b`, and `c`.

#### Truth Table Example:

| a | b | c | Output |
| - | - | - | ------ |
| 0 | 0 | 0 | 1      |
| 0 | 0 | 1 | 1      |
| 0 | 1 | 0 | 0      |
| 0 | 1 | 1 | 0      |
| 1 | 0 | 0 | 0      |
| 1 | 0 | 1 | 0      |
| 1 | 1 | 0 | 0      |
| 1 | 1 | 1 | 0      |

This is perfectly accurate but can become **cumbersome** with more variables.

---

#### Karnaugh Map Layout

#### K-Map Setup (for 3 variables):

|       | **00** | **01** | **11** | **10** |
| ----- | ------ | ------ | ------ | ------ |
| **0** | 1      | 1      | 0      | 0      |
| **1** | 0      | 0      | 0      | 0      |

* **Top row (columns)**: combinations of `b` and `c` in **Gray Code** order (00, 01, 11, 10)
* **First column (rows)**: values for variable `a` (0 and 1)
* **Cells**: represent the **output** for that combination of inputs

> **Gray Code** ensures only one bit changes between adjacent cells, enabling easier grouping and pattern detection.

---

#### Simplification with Karnaugh Maps

From the map above, we see that the **first row, first two columns** (a = 0, bc = 00 and 01) contain 1s. This indicates:

```
a' b' c' + a' b' c  → a' b'
```

We grouped two adjacent cells to reduce the original expression. This **removes variable `c`**, simplifying the function.

#### Why it works:

* `a = 0` → `a'`
* `b = 0` → `b'`
* `c` varies, so it's not included in the simplified term

---

#### Key Features of a K-Map

1. **Gray Code Order**: Ensures adjacent cells differ by only one variable.
2. **Only '1' Outputs**: Focuses simplification on conditions that produce a TRUE output.
3. **Visual Groupings**: Groups of 1s in sizes of 1, 2, 4, 8… allow collapsing expressions.
4. **Split Variables**: Row and column headers divide the variables (usually half in each).

---

#### Lesson Summary

* A **Karnaugh Map** simplifies Boolean expressions involving 2–6 variables.
* Unlike truth tables, K-Maps use **Gray Code**, allowing for easy visual grouping.
* Outputs of **1** are the focus (we minimize based on where the function is true).
* **Group adjacent 1s** (horizontally or vertically, not diagonally) into rectangles of 1, 2, 4, 8 cells.
* Each group results in a **simplified product term** in the Boolean expression.

**K-Maps make it easy to quickly minimize logical expressions**, essential for efficient circuit design and programming logic.

### Section 5: Arithmetic Logic Unit (ALU)

#### Definition

An **Arithmetic Logic Unit (ALU)** is a digital circuit within a computer's **Central Processing Unit (CPU)** responsible for performing **arithmetic** and **logical** operations. It is a core component of every modern CPU, working alongside the **control unit (CU)** and registers to execute instruction-level tasks.

---

#### Key Responsibilities

* **Arithmetic operations**:

  * Addition
  * Subtraction
  * Multiplication
  * Division

* **Logic operations**:

  * NOT
  * AND
  * OR
  * XOR
  * Comparison (e.g., equal, greater than, less than)

---

#### Role in the CPU

1. **Data Loading**: The ALU receives input from **registers**, which are small storage locations in the CPU.
2. **Control Signals**: The **Control Unit (CU)** issues commands that determine which operation the ALU should perform.
3. **Execution**: The ALU processes the data using logic gates and arithmetic circuitry.
4. **Output**: The result is stored back in an **output register** or sent to memory.

---

#### How It Works: Binary and Logic Gates

All ALU operations rely on **binary data (0 and 1)** and **transistor-based logic gates**.

| Gate    | Input A | Input B | Output | Description                  |
| ------- | ------- | ------- | ------ | ---------------------------- |
| **NOT** | A       | –       | ¬A     | Inverts the input            |
| **AND** | A       | B       | A ∧ B  | True only if both are 1      |
| **OR**  | A       | B       | A ∨ B  | True if at least one is 1    |
| **XOR** | A       | B       | A ⊕ B  | True if inputs are different |

These gates are built from **transistors**, which act like on/off switches:

* **Open switch (no current)** = 0
* **Closed switch (current flows)** = 1

---

#### Example: Binary Addition

To add **2 (10)** and **3 (11)**:

* The ALU uses a combination of **AND**, **OR**, and **XOR** gates.
* Binary addition results in **101**, which equals **5 in decimal**.

This method, although seemingly slow, is executed in **billions of operations per second** due to modern CPU speeds (measured in **GHz**), enabling rapid and accurate processing.

---

#### Real-World Performance

* Modern CPUs contain **millions to billions of transistors**
* ALUs are optimized to handle **multi-bit operations** simultaneously (e.g., 32-bit, 64-bit)
* Can handle complex instructions such as floating-point math, bit shifting, and conditional logic

---

#### Summary

* The **ALU** is the **computational core** of the CPU.
* It uses **binary logic** and **transistors** to perform **arithmetic and logical operations**.
* ALUs rely on fundamental **logic gates** (NOT, AND, OR, XOR) to compute.
* These operations are the basis for **all computing tasks**, from simple math to complex simulations.

### Section 6: Designing Logic Circuits

#### Overview: Design vs. Analysis

In digital systems, there are two core processes:

* **Analysis**:
  *Understanding what a given circuit does by converting it into a truth table or readable specification.*

* **Design**:
  *Creating a logic circuit from a human-readable specification.*

This lesson focuses on the **design** process, using a structured approach:

1. **Derive the truth table** from the specification.
2. **Use a Karnaugh Map** to simplify the Boolean function.
3. **Draw the logic circuit** using gates (AND, OR, NOT).

---

#### Example 1: Weighted Voting System

*Company Board of Directors with Voting Weights:*

* Director A = 20%
* Director B = 30%
* Director C = 50%
* A decision passes if it receives **>50%** approval.

**Step 1: Truth Table**

| C | B | A | Z |
| - | - | - | - |
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 |

**Step 2: Karnaugh Map Simplification**

* From the map: `Z = AC + BC`
* Further simplification: `Z = C(A + B)`

**Step 3: Logic Circuit Diagram**

* Use two gates only:
  *One OR gate for `A + B`*
  *One AND gate for `C(A + B)`*

---

#### Example 2: Divisibility by 3

*Design a circuit that outputs 1 if a 4-bit binary number is divisible by 3.*

**Step 1: Truth Table**

| D | C | B | A | Z |
| - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 1 | 1 | 1 |
| 0 | 0 | 1 | 0 | 0 |
| 0 | 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 0 |
| 1 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 1 |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 | 0 |

**Step 2: Karnaugh Map**

* The resulting Karnaugh Map **cannot be simplified**.

**Step 3: Logic Equation**

The unsimplified equation must be implemented directly using multiple gates representing each minterm for which `Z = 1`.

---

#### Summary

To **design a logic circuit**:

1. **Interpret the specification** and build a truth table.
2. **Use Karnaugh Maps** to simplify the Boolean function when possible.
3. **Draw the circuit diagram** using basic logic gates.

These tools are foundational to creating more complex systems like **ALUs** or even entire **CPUs**.

### Section 7: Logic Truth Tables & Logic Gates

#### Basic Logic Gates: AND, OR, NOT

The three fundamental Boolean logic operations are:

* **AND Gate**: Output is true only if both inputs are true.
* **OR Gate**: Output is true if at least one input is true.
* **NOT Gate**: Output is the inverse (negation) of the input.

| Input A | Input B | A AND B | A OR B |
| ------- | ------- | ------- | ------ |
| 0       | 0       | 0       | 0      |
| 0       | 1       | 0       | 1      |
| 1       | 0       | 0       | 1      |
| 1       | 1       | 1       | 1      |

| Input | NOT A |
| ----- | ----- |
| 0     | 1     |
| 1     | 0     |

---

#### Extended Logic Gates: NAND, NOR, XOR

These gates add flexibility and are defined as follows:

* **NAND** (NOT AND):
  `NAND(A, B) = NOT(A AND B)`

* **NOR** (NOT OR):
  `NOR(A, B) = NOT(A OR B)`

* **XOR** (Exclusive OR):
  `XOR(A, B) = (A AND NOT B) OR (NOT A AND B)`

| A | B | NAND | NOR | XOR |
| - | - | ---- | --- | --- |
| 0 | 0 | 1    | 1   | 0   |
| 0 | 1 | 1    | 0   | 1   |
| 1 | 0 | 1    | 0   | 1   |
| 1 | 1 | 0    | 0   | 0   |

---

#### Gate Equivalents Using NAND

NAND gates can replicate other basic logic functions:

* **NOT Gate Using NAND**:
  `NOT(A) = NAND(A, A)`

* **AND Gate Using NAND**:
  `AND(A, B) = NAND(NAND(A, B), NAND(A, B))`

* **OR Gate Using NAND**:
  `OR(A, B) = NAND(NAND(A, A), NAND(B, B))`

This ability to form all other gates using **only NAND gates** is called **functional completeness**.

---

#### Gate Equivalents Using NOR

Similarly, NOR gates can also replicate any logic operation:

* **NOT(A) = NOR(A, A)**
* **AND(A, B) = NOR(NOR(A, A), NOR(B, B))**
* **OR(A, B) = NOR(NOR(A, B), NOR(A, B))**

---

#### Functional Completeness

* **NAND and NOR gates** are **functionally complete**.
* Any digital logic circuit can be constructed using **only NAND** or **only NOR** gates.
* This is both practical and efficient in circuit design, especially for microprocessors, as NAND and NOR gates use fewer transistors.

---

#### Summary

* Basic gates: **AND**, **OR**, **NOT**
* Extended gates: **NAND**, **NOR**, **XOR**
* NAND and NOR gates are **functionally complete**.
* Any logic operation can be implemented using **only NAND** or **only NOR** gates, making them essential in digital system design.

### Section 8: Simplifying Logic Circuits

#### Why Simplify Logic Expressions?

Simplifying logic circuits reduces hardware complexity and improves system performance. Simpler circuits:

* Require **fewer logic gates**
* **Consume less power**
* **Occupy less space** on an integrated circuit
* Are **less expensive** to manufacture and maintain

Logic functions can be expressed as:

* **Truth tables**
* **Boolean expressions**
* **Logic circuit schematics**

---

#### Methods for Simplification

* **Boolean Algebra Laws** — best for small expressions
* **Karnaugh Maps (K-Maps)** — useful for up to 5–6 variables
* **Quine-McCluskey Algorithm** — for larger, more complex expressions

---

#### Example: Boolean Expression Simplification

Given:

```
F = ab'c'd' + a'b'cd' + ab'cd' + a'b'c'd + ab'c'd + a'bc'd + 
    a'b'cd' + a'b'cd + ab'cd + a'bcd + abcd
```

This expression has:

* **11 product terms**
* Up to **4 variables per term**

---

#### Step 1: Build the Complex Circuit

Each **AND gate** corresponds to a product term
All terms are summed using an **OR gate**

Result:

* Circuit with **11 AND gates** and **1 OR gate**
* Many inverted inputs (NOT gates)

---

#### Step 2: Use Karnaugh Map to Simplify

The Karnaugh Map reveals that the expression simplifies to:

```
F = d + ab' + b'c
```

This has:

* **Only 3 product terms**
* Each term has **1 or 2 variables**

---

#### Step 3: Build the Simplified Circuit

* One **OR gate** to sum the terms
* Three **AND gates** (for `ab'` and `b'c`)
* One **direct wire** for `d` (no gate needed)

Result:

* Significantly reduced gate count (from 12 to **3 total gates**)
* Less complex wiring and layout
* Lower cost and power consumption

---

#### Lesson Summary

To simplify a logic circuit:

1. **Start with a Boolean expression**
2. **Use Karnaugh maps or Boolean algebra** to simplify
3. **Redraw the simplified circuit**

Benefits of simplification:

* Reduces number of gates
* Minimizes power usage
* Saves space and cost in hardware design

Efficient circuit design begins with proper simplification of Boolean logic.
