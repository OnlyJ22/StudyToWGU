### Section 1: Java Sets

#### What Is a Set?

* A **Set** in Java is a collection of items of the **same data type**.
* A Set **cannot contain duplicates** — each value is unique.
* Set is part of the **Collections framework** and is an **interface**, which means we use classes like `HashSet` or `TreeSet` to create sets.
* You must import Java utility classes before using them:

```java
import java.util.*;
public class Main {
  public static void main(String[] args) {
    // put all code after this line
  }
}
```

#### Creating & Iterating in the Set

* A **`HashSet`** is an unordered set — Java decides the order.
* A **`TreeSet`** keeps elements in **ascending order**.

```java
// create our Set
Set<String> trees = new HashSet<>();
trees.add("Larch");
trees.add("Pine");
trees.add("Balsam");
trees.add("Birch");
trees.add("Ash");
```

```java
// iterate over set
for (String s : trees) {
  System.out.println("Tree = " + s);
}
```

* The order in the output is **not the same** as insertion order.
* It is **not random**, but is **defined internally** by Java's implementation of `HashSet`.

```java
// forEach loop (Java 8+)
trees.forEach(System.out::println);
```

* The `forEach()` method works the same but uses **lambda-style syntax**.

```java
// Iterator example
Iterator<String> ir = trees.iterator();
while (ir.hasNext()) {
  System.out.println("Iterator Result = " + ir.next());
}
```

#### A Different Set

* Now using **`TreeSet`**, which keeps values in **ascending order**.

```java
// create our Set
Set<String> trees = new TreeSet<>();
trees.add("Larch");
trees.add("Pine");
trees.add("Balsam");
trees.add("Birch");
trees.add("Ash");

Iterator<String> ir = trees.iterator();
while (ir.hasNext()) {
  System.out.println("Iterator Result = " + ir.next());
}
```

* Output is in alphabetical order: `Ash`, `Balsam`, `Birch`, etc.

#### TreeSet with Double

```java
Set<Double> scores = new TreeSet<>();
scores.add(1.59343);
scores.add(0.9934847);
scores.add(-3.3444);

Iterator<Double> ir = scores.iterator();
while (ir.hasNext()) {
  System.out.println("Score: " + ir.next());
}
```

* Double values will appear in **numeric ascending order**.

#### Full Working Code

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {

    // HashSet example
    Set<String> hashSetTrees = new HashSet<>();
    hashSetTrees.add("Larch");
    hashSetTrees.add("Pine");
    hashSetTrees.add("Balsam");
    hashSetTrees.add("Birch");
    hashSetTrees.add("Ash");

    System.out.println("HashSet Trees:");
    for (String s : hashSetTrees) {
      System.out.println("Tree = " + s);
    }

    hashSetTrees.forEach(System.out::println);

    Iterator<String> hashSetIterator = hashSetTrees.iterator();
    while (hashSetIterator.hasNext()) {
      System.out.println("HashSet Iterator Result = " + hashSetIterator.next());
    }

    // TreeSet example
    Set<String> treeSetTrees = new TreeSet<>();
    treeSetTrees.add("Larch");
    treeSetTrees.add("Pine");
    treeSetTrees.add("Balsam");
    treeSetTrees.add("Birch");
    treeSetTrees.add("Ash");

    System.out.println("TreeSet Trees:");
    Iterator<String> treeSetIterator = treeSetTrees.iterator();
    while (treeSetIterator.hasNext()) {
      System.out.println("TreeSet Iterator Result = " + treeSetIterator.next());
    }

    // TreeSet with Double example
    Set<Double> scores = new TreeSet<>();
    scores.add(1.59343);
    scores.add(0.9934847);
    scores.add(-3.3444);

    System.out.println("Scores:");
    Iterator<Double> scoresIterator = scores.iterator();
    while (scoresIterator.hasNext()) {
      System.out.println("Score: " + scoresIterator.next());
    }
  }
}
```

### Section 2: Map Data Type

#### What Is a Map?

* A **map** is an abstract data type (ADT) that stores **key-value pairs**.
* It functions like a **dictionary**:

  * The **key** is used to identify a value.
  * The **value** is the data associated with that key.
* Each **key must be unique** — duplicate keys are not allowed.
* A map is often called an **associative array**, because it stores associations between keys and values.
* A real-world example:

  * **Key**: Locker number
  * **Value**: Key code or lock combo

#### Key Features of Java Maps

* Java implements the map ADT through several classes:

  * `HashMap` – unordered
  * `TreeMap` – keys sorted in natural order
  * `Hashtable` – synchronized and doesn't allow `null` keys or values
* A map can display:

  * Only keys
  * Only values
  * Key-value pairs together

#### Using Maps in Java

* To use maps, import Java utilities:

  ```java
  import java.util.*;
  ```

* Example structure to begin writing map logic:

  ```java
  import java.util.HashMap;
  import java.util.Map;

  public class Main {
    public static void main(String[] args) {
      // put all map logic here
    }
  }
  ```

#### Inserting Values Using `put()`

* Example:

  ```java
  Map<String, Integer> arrayCars = new HashMap<String, Integer>();
  arrayCars.put("Toyota", 6);
  arrayCars.put("Ford", 10);
  arrayCars.put("Honda", 5);
  arrayCars.put("Chrysler", 4);
  arrayCars.put("Honda", 10);
  ```

* Result:

  * `"Honda"` is inserted with value `5`
  * `"Honda"` is then **updated** to value `10` — duplicates not allowed

#### Retrieving a Value with `get()`

* Example:

  ```java
  System.out.println(arrayCars.get("Honda"));
  ```

* Output:
  `10`

#### Checking for a Value with `containsValue()`

* Example:

  ```java
  System.out.println(arrayCars.containsValue(2));
  ```

* Output:
  `false`

* Example:

  ```java
  System.out.println(arrayCars.containsValue(10));
  ```

* Output:
  `true`

#### Checking for a Key with `containsKey()`

* Example:

  ```java
  if (arrayCars.containsKey("Honda")) {
    System.out.println(arrayCars.containsKey("Honda"));
  }
  ```

* Output:
  `true`

#### Finding Size with `size()`

* Example:

  ```java
  System.out.println(arrayCars.size());
  ```

* Output:
  `4`

* Explanation:
  There are four key-value pairs (the second `"Honda"` replaced the first).

### Section 3: Hash Tables

* Hash tables are a **data structure** used for fast data storage and retrieval.
* They operate on **key-value pairs**, where each key is mapped to a specific index using a **hash function**.
* Hash tables are **efficient** because lookup time does not grow linearly with the size of the data.

#### Hashing and Collisions

* **Hashing** is the process of transforming a key into an index using a hash function.
* Data is stored in **buckets** at these indexes.
* The same hash function is used for both storing and retrieving data.
* A **collision** occurs when two keys are hashed to the same index.
* Collisions are expected and must be **resolved** efficiently.

#### Hash Functions

* A **good hash function** should:

  * Be easy to compute
  * Distribute keys uniformly
* One common method is **modular hashing**:

  * Let `M` be a **prime number**
  * For key `k`, index = `k % M`
* Even with a good hash function, **collisions are likely** — especially as the table fills up.

#### Collision Resolution

* **Linked Lists**:

  * Multiple values can be stored at the same index using a list.
  * Typically results in just 2–3 elements per bucket.
* **Open Addressing**:

  * When a collision occurs, a **probe sequence** is used to find the next empty slot.
  * More efficient than linked lists when the table is not overly full.
  * Efficiency drops once the table is about **80% full**.

#### Example

* A company with **1000 employees** stores them in a hash table.
* The hash function is based on **first letter of first name + first letter of last name**, creating **676 keys**.
* This guarantees **collisions** (e.g., multiple people with initials "JD").
* If **linked lists** are used, multiple employees with the same key can coexist at one index.

#### Lesson Summary

* Hash tables store **key-value pairs** and offer **fast lookup times**.
* A **hash function** converts keys into indexes. A good function is simple and spreads keys evenly.
* **Modular hashing** is effective: `k % M`, where `M` is prime.
* **Collisions** are handled using methods like:

  * **Linked lists** (chaining)
  * **Open addressing** (probing)
* The right collision strategy depends on expected data size and use case.
Here is your content on **Binary Search Trees**, properly formatted using your preferred structure — one main heading, indented subpoints, clear rule and scenario breakdown, no extra sections, and no summary headings.

### Section 4: Binary Search Tree

* A **Binary Search Tree (BST)** is a binary tree where each node contains a **maximum of two child nodes**.
* Each node has a **search key**, and its placement follows strict **binary search rules** to keep the tree balanced.
* BST enables fast **searching, adding, and removing** operations due to its structure.

#### Binary Search Properties

* Rule 1: Each node can have **up to two child nodes**.
* Rule 2: **Child nodes may be missing**; not all nodes have to be full.
* Rule 3: **Left child nodes** must have values **less than** the parent.
* Rule 4: **Right child nodes** must have values **greater than** the parent.

#### BST as Sort Maps

* A BST is similar to a **sort map**, where each element is searchable via a **unique identifier (key)**.
* This structure makes search operations efficient.

#### BST Operations

* The main operations supported by a BST:

  * **Search** for an element
  * **Add** a new element
  * **Remove** an existing element

##### Search

* Uses a **recursive algorithm** to find a node.
* If the tree is **empty**, the search returns a **miss**.
* If the tree is not empty:

  * Compare the key with the **root node**.
  * If the key is **less**, search the **left** subtree.
  * If the key is **greater**, search the **right** subtree.
  * Repeat until the key is found or a leaf is reached.

##### Add a Node

* If the tree is **empty**, the new key becomes the **root node**.
* Otherwise:

  * Use the same recursive method to find the correct location.
  * The new key is added such that **BST rules are preserved**.
  * No duplicate keys are allowed.

##### Remove a Node

* Four possible cases to consider:

  * **Scenario 1**: Node is **not in the tree**.

    * Result: No action taken.

  * **Scenario 2**: Node is a **leaf** (no children).

    * Action: Node is simply **removed**.

  * **Scenario 3**: Node has **one child**.

    * Action: Child is **relinked** to the node’s parent, and the node is removed.

  * **Scenario 4**: Node has **two children**.

    * Action: Find a **replacement node** (in-order successor or predecessor).
    * **Swap** the node with its replacement.
    * Adjust any child pointers to maintain **BST rules**.
