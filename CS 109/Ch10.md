### Section 1: Java Sets

#### What Is a Set?

* A **Set** in Java is a collection of items of the **same data type**.
* A Set **cannot contain duplicates** — each value is unique.
* Set is part of the **Collections framework** and is an **interface**, which means we use classes like `HashSet` or `TreeSet` to create sets.
* You must import Java utility classes before using them:

```java
import java.util.*;
public class Main {
  public static void main(String[] args) {
    // put all code after this line
  }
}
```

#### Creating & Iterating in the Set

* A **`HashSet`** is an unordered set — Java decides the order.
* A **`TreeSet`** keeps elements in **ascending order**.

```java
// create our Set
Set<String> trees = new HashSet<>();
trees.add("Larch");
trees.add("Pine");
trees.add("Balsam");
trees.add("Birch");
trees.add("Ash");
```

```java
// iterate over set
for (String s : trees) {
  System.out.println("Tree = " + s);
}
```

* The order in the output is **not the same** as insertion order.
* It is **not random**, but is **defined internally** by Java's implementation of `HashSet`.

```java
// forEach loop (Java 8+)
trees.forEach(System.out::println);
```

* The `forEach()` method works the same but uses **lambda-style syntax**.

```java
// Iterator example
Iterator<String> ir = trees.iterator();
while (ir.hasNext()) {
  System.out.println("Iterator Result = " + ir.next());
}
```

#### A Different Set

* Now using **`TreeSet`**, which keeps values in **ascending order**.

```java
// create our Set
Set<String> trees = new TreeSet<>();
trees.add("Larch");
trees.add("Pine");
trees.add("Balsam");
trees.add("Birch");
trees.add("Ash");

Iterator<String> ir = trees.iterator();
while (ir.hasNext()) {
  System.out.println("Iterator Result = " + ir.next());
}
```

* Output is in alphabetical order: `Ash`, `Balsam`, `Birch`, etc.

#### TreeSet with Double

```java
Set<Double> scores = new TreeSet<>();
scores.add(1.59343);
scores.add(0.9934847);
scores.add(-3.3444);

Iterator<Double> ir = scores.iterator();
while (ir.hasNext()) {
  System.out.println("Score: " + ir.next());
}
```

* Double values will appear in **numeric ascending order**.

#### Full Working Code

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {

    // HashSet example
    Set<String> hashSetTrees = new HashSet<>();
    hashSetTrees.add("Larch");
    hashSetTrees.add("Pine");
    hashSetTrees.add("Balsam");
    hashSetTrees.add("Birch");
    hashSetTrees.add("Ash");

    System.out.println("HashSet Trees:");
    for (String s : hashSetTrees) {
      System.out.println("Tree = " + s);
    }

    hashSetTrees.forEach(System.out::println);

    Iterator<String> hashSetIterator = hashSetTrees.iterator();
    while (hashSetIterator.hasNext()) {
      System.out.println("HashSet Iterator Result = " + hashSetIterator.next());
    }

    // TreeSet example
    Set<String> treeSetTrees = new TreeSet<>();
    treeSetTrees.add("Larch");
    treeSetTrees.add("Pine");
    treeSetTrees.add("Balsam");
    treeSetTrees.add("Birch");
    treeSetTrees.add("Ash");

    System.out.println("TreeSet Trees:");
    Iterator<String> treeSetIterator = treeSetTrees.iterator();
    while (treeSetIterator.hasNext()) {
      System.out.println("TreeSet Iterator Result = " + treeSetIterator.next());
    }

    // TreeSet with Double example
    Set<Double> scores = new TreeSet<>();
    scores.add(1.59343);
    scores.add(0.9934847);
    scores.add(-3.3444);

    System.out.println("Scores:");
    Iterator<Double> scoresIterator = scores.iterator();
    while (scoresIterator.hasNext()) {
      System.out.println("Score: " + scoresIterator.next());
    }
  }
}
```

### Section 2: Map Data Type

#### What Is a Map?

* A **map** is an abstract data type (ADT) that stores **key-value pairs**.
* It functions like a **dictionary**:

  * The **key** is used to identify a value.
  * The **value** is the data associated with that key.
* Each **key must be unique** — duplicate keys are not allowed.
* A map is often called an **associative array**, because it stores associations between keys and values.
* A real-world example:

  * **Key**: Locker number
  * **Value**: Key code or lock combo

#### Key Features of Java Maps

* Java implements the map ADT through several classes:

  * `HashMap` – unordered
  * `TreeMap` – keys sorted in natural order
  * `Hashtable` – synchronized and doesn't allow `null` keys or values
* A map can display:

  * Only keys
  * Only values
  * Key-value pairs together

#### Using Maps in Java

* To use maps, import Java utilities:

  ```java
  import java.util.*;
  ```

* Example structure to begin writing map logic:

  ```java
  import java.util.HashMap;
  import java.util.Map;

  public class Main {
    public static void main(String[] args) {
      // put all map logic here
    }
  }
  ```

#### Inserting Values Using `put()`

* Example:

  ```java
  Map<String, Integer> arrayCars = new HashMap<String, Integer>();
  arrayCars.put("Toyota", 6);
  arrayCars.put("Ford", 10);
  arrayCars.put("Honda", 5);
  arrayCars.put("Chrysler", 4);
  arrayCars.put("Honda", 10);
  ```

* Result:

  * `"Honda"` is inserted with value `5`
  * `"Honda"` is then **updated** to value `10` — duplicates not allowed

#### Retrieving a Value with `get()`

* Example:

  ```java
  System.out.println(arrayCars.get("Honda"));
  ```

* Output:
  `10`

#### Checking for a Value with `containsValue()`

* Example:

  ```java
  System.out.println(arrayCars.containsValue(2));
  ```

* Output:
  `false`

* Example:

  ```java
  System.out.println(arrayCars.containsValue(10));
  ```

* Output:
  `true`

#### Checking for a Key with `containsKey()`

* Example:

  ```java
  if (arrayCars.containsKey("Honda")) {
    System.out.println(arrayCars.containsKey("Honda"));
  }
  ```

* Output:
  `true`

#### Finding Size with `size()`

* Example:

  ```java
  System.out.println(arrayCars.size());
  ```

* Output:
  `4`

* Explanation:
  There are four key-value pairs (the second `"Honda"` replaced the first).

### Section 3: Hash Tables

* Hash tables are a **data structure** used for fast data storage and retrieval.
* They operate on **key-value pairs**, where each key is mapped to a specific index using a **hash function**.
* Hash tables are **efficient** because lookup time does not grow linearly with the size of the data.

#### Hashing and Collisions

* **Hashing** is the process of transforming a key into an index using a hash function.
* Data is stored in **buckets** at these indexes.
* The same hash function is used for both storing and retrieving data.
* A **collision** occurs when two keys are hashed to the same index.
* Collisions are expected and must be **resolved** efficiently.

#### Hash Functions

* A **good hash function** should:

  * Be easy to compute
  * Distribute keys uniformly
* One common method is **modular hashing**:

  * Let `M` be a **prime number**
  * For key `k`, index = `k % M`
* Even with a good hash function, **collisions are likely** — especially as the table fills up.

#### Collision Resolution

* **Linked Lists**:

  * Multiple values can be stored at the same index using a list.
  * Typically results in just 2–3 elements per bucket.
* **Open Addressing**:

  * When a collision occurs, a **probe sequence** is used to find the next empty slot.
  * More efficient than linked lists when the table is not overly full.
  * Efficiency drops once the table is about **80% full**.

#### Example

* A company with **1000 employees** stores them in a hash table.
* The hash function is based on **first letter of first name + first letter of last name**, creating **676 keys**.
* This guarantees **collisions** (e.g., multiple people with initials "JD").
* If **linked lists** are used, multiple employees with the same key can coexist at one index.

#### Lesson Summary

* Hash tables store **key-value pairs** and offer **fast lookup times**.
* A **hash function** converts keys into indexes. A good function is simple and spreads keys evenly.
* **Modular hashing** is effective: `k % M`, where `M` is prime.
* **Collisions** are handled using methods like:

  * **Linked lists** (chaining)
  * **Open addressing** (probing)
* The right collision strategy depends on expected data size and use case.

### Section 4: Binary Search Tree

* A **Binary Search Tree (BST)** is a binary tree where each node contains a **maximum of two child nodes**.
* Each node has a **search key**, and its placement follows strict **binary search rules** to keep the tree balanced.
* BST enables fast **searching, adding, and removing** operations due to its structure.

#### Binary Search Properties

* Rule 1: Each node can have **up to two child nodes**.
* Rule 2: **Child nodes may be missing**; not all nodes have to be full.
* Rule 3: **Left child nodes** must have values **less than** the parent.
* Rule 4: **Right child nodes** must have values **greater than** the parent.

#### BST as Sort Maps

* A BST is similar to a **sort map**, where each element is searchable via a **unique identifier (key)**.
* This structure makes search operations efficient.

#### BST Operations

* The main operations supported by a BST:

  * **Search** for an element
  * **Add** a new element
  * **Remove** an existing element

##### Search

* Uses a **recursive algorithm** to find a node.
* If the tree is **empty**, the search returns a **miss**.
* If the tree is not empty:

  * Compare the key with the **root node**.
  * If the key is **less**, search the **left** subtree.
  * If the key is **greater**, search the **right** subtree.
  * Repeat until the key is found or a leaf is reached.

##### Add a Node

* If the tree is **empty**, the new key becomes the **root node**.
* Otherwise:

  * Use the same recursive method to find the correct location.
  * The new key is added such that **BST rules are preserved**.
  * No duplicate keys are allowed.

##### Remove a Node

* Four possible cases to consider:

  * **Scenario 1**: Node is **not in the tree**.

    * Result: No action taken.

  * **Scenario 2**: Node is a **leaf** (no children).

    * Action: Node is simply **removed**.

  * **Scenario 3**: Node has **one child**.

    * Action: Child is **relinked** to the node’s parent, and the node is removed.

  * **Scenario 4**: Node has **two children**.

    * Action: Find a **replacement node** (in-order successor or predecessor).
    * **Swap** the node with its replacement.
    * Adjust any child pointers to maintain **BST rules**.

### Section 5: Binary Search

* **Binary Search** is a fast algorithm used to search for an element in a **sorted array** by repeatedly dividing the search interval in half.
* Also known as the **divide and conquer** method.
* Much faster and more efficient than linear search, especially for large datasets.

#### Sorted Array Binary Search

* A **sorted array** has elements arranged in **ascending order**.
* Binary search works by checking the **middle value** of the current interval:

  * If the key is **less**, search the **left** half.
  * If the key is **greater**, search the **right** half.
  * If the key **matches**, return the index.
* This is implemented **recursively**, and requires:

  * The array itself
  * Starting index
  * Ending index
  * Key to search for

```java
int[] sortedArr = {1, 53, 62, 133, 384, 553, 605, 897, 1035, 1234};
```

```java
public static int recursiveBinarySearch(int[] sortedArray, int begin, int end, int key) {
    if (begin < end) {
        int middle = begin + (end - begin) / 2;
        if(key < sortedArray[middle]) {
            return recursiveBinarySearch(sortedArray, begin, middle, key);
        } else if (key > sortedArray[middle]) {
            return recursiveBinarySearch(sortedArray, middle+1, end, key);
        } else {
            return middle;
        }
    }
    // Not found
    return -1;
}
```

```java
public static void main(String[] args) {
    int[] sortedArr = {1, 53, 62, 133, 384, 553, 605, 897, 1035, 1234};
    int searchIndex = recursiveBinarySearch(sortedArr, 0, sortedArr.length, 605);
    System.out.println("I Found 605 at index " + searchIndex);
}
```

* Output:

```
I Found 605 at index 6
```

#### Unsorted Array Binary Search

* Binary search **cannot** be used directly on an unsorted array.
* First, use the `Arrays.sort()` method to sort the array.

```java
int[] unsortedArr = {55, 556, 12, 34, 0, 1023, 1567, 32};
Arrays.sort(unsortedArr);
System.out.println("Sorted Array Now: ");
for(int i = 0; i < unsortedArr.length; i++) {
    System.out.println("#" + i + " Value = " + unsortedArr[i]);
}
```

* After sorting, binary search can be applied:

```java
int searchIndexU = recursiveBinarySearch(unsortedArr, 0, unsortedArr.length, 1023);
System.out.println("I Found 1023 at index " + searchIndexU);
```

* Output:

```
I Found 1023 at index 6
```

### Section 6: Graph Theory

* **Graph Theory** is a field of mathematics and computer science focused on studying graphs—structures made of **vertices** (nodes) and **edges** (connections).
* It is widely used in real-world applications such as **public transportation**, **utility networks**, **network routing**, and **logistics optimization**.

#### A Graph

* A **graph** is a visual representation of relationships between objects.
* In its simplest form, a graph has:

  * **Points (vertices)** representing entities (e.g., cities, routers, poles).
  * **Lines (edges)** representing connections (e.g., roads, cables, paths).

```
Example: A map with cities A, B, C, D connected by roads
```

#### Vertices

* A **vertex** (plural: **vertices**) is a **point** on the graph.
* Vertices represent data entities or endpoints.
* A vertex can have:

  * **One** or **multiple edges** connected to it.
  * **Zero** edges in special cases (isolated node).
* Example:

  * Vertex **A** is connected to two others.
  * Vertex **B** is connected to **three** others.

#### Edges

* An **edge** is a **line** connecting two vertices.
* Edges represent the relationship or path between vertices.
* Examples:

  * **A–B** is an edge.
  * **B–D** is another edge.
* Paths can be **direct** (A to B) or **indirect** (A to C via B).

#### Loops

* A **loop** is an edge that connects a vertex **to itself**.
* Visually, it appears as a **curved line looping back** to the same point.
* Loops are **optional** in graphs and may or may not be allowed based on the problem.
* Example:

  * A loop at vertex **C** means there's an edge starting and ending at **C**.

#### Summary

* Graph Theory allows for **analysis of relationships and paths** between objects.
* Key components:

  * **Vertices** – the points or nodes.
  * **Edges** – the lines or connections between points.
  * **Loops** – special edges connecting a vertex to itself.
* This is the basis for many advanced algorithms in **navigation**, **search engines**, and **network design**.

### Section 7: Shortest Path Problem

#### Real-World Example

* Using **Google Maps** to find the shortest route or cheapest fuel route is an example of the **shortest path problem**.
* In math, this is the problem of finding the **shortest possible distance between two vertices on a graph**.

#### Weighted Graphs

* A **weighted graph** includes:

  * **Vertices**: Locations (e.g., your house, Divya's house)
  * **Edges**: Routes between them
  * **Weights**: The numerical values (e.g., distance, cost) on the edges

#### Dijkstra’s Algorithm

* A method to **find the shortest path or minimum cost** from a starting point to an ending point on a graph.
* It works by exploring the **shortest known distance from the end**, moving backwards.

#### Dijkstra’s Algorithm Steps

1. **Start at the ending vertex** (e.g., Divya's house) and **mark it 0**. Circle it — this is the current vertex.
2. **For all connected vertices**, mark their distances by adding the weight of the connecting edge to the current vertex’s distance.
3. **Mark the current vertex as visited** (put an “X” over it).
4. From the marked vertices, **choose the one with the smallest value** and make it the new current vertex.
5. **Repeat steps 2–4** until the **starting vertex is visited**.
6. The value at the starting vertex is the **shortest path distance**. The path that led to this value is the **shortest route**.

#### Step-by-Step Example

**Goal**: Find the shortest path from **your house** to **Divya’s house**.

* **Start** at Divya’s house:

  * Mark: 0
  * Mark distances:

    * Movie theater = 0 + 4 = 4
    * Grocery store = 0 + 5 = 5
    * Gas station = 0 + 6 = 6
  * Visit Divya’s house

* **Next current vertex**: Movie theater (mark: 4)

  * Grocery store = 4 + 2 = 6 → keep 5
  * Your house = 4 + 3 = 7 → mark 7
  * Visit movie theater

* **Next current vertex**: Grocery store (mark: 5)

  * Gas station = 5 + 1 = 6 → keep 6
  * Your house = 5 + 4 = 9 → keep 7
  * Visit grocery store

* **Next current vertex**: Gas station (mark: 6)

  * Your house = 6 + 2 = 8 → keep 7
  * Visit gas station

* **Next current vertex**: Your house (mark: 7)

  * Visit your house — algorithm ends

#### Final Result

* **Shortest path distance**: 7
* **Path**: Your house → Movie theater → Divya’s house

#### Lesson Summary

* The **Shortest Path Problem** finds the minimum distance or cost between two points in a graph.
* **Dijkstra's Algorithm** is a step-by-step method for solving this.
* It works by **marking distances**, always choosing the **smallest current distance**, and **visiting nodes** in that order.
* This algorithm is widely used in **GPS systems**, **network routing**, and other optimization problems.
